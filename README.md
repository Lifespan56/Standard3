분석 문제 : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.



차이

입문주차 : InputValue 

InputSystem에서 Action이름 앞에 On이붙은 것을 함수명으로 사용해야만함

입력값 > 전처리 > 델리게이트(함수포인터)



현재주차 : InputActioncontext

UI버튼에 연결하는 방식 함수명이 자유로움

입력값 > 전처리 > 관련 함수 직접호출
조건문 누르기 시작했을 때, 누르고 있을 때, 땠을 때 추가



공통점 : 매개변수로 받는 값을 Vector계산 전처리 후 움직임



CharacterManager와 Player의 역할에 대해 고민해보세요.

CharacterManager 싱글톤 외부에서의 접근이 많은 개체의 중계역할

현재 구조 : 외부에서 많이 불러갈 개체(Player)가 CharacterManager 의 프로퍼티에 접근
CharacterManager는 프로퍼티를 통해 이 개체(Player)의 정보를 호출자에게 전달

스크립트상에서 싱글톤에대한 접근이 쉬움
싱글톤이 없다면? GameObject Player.gameObject.GetComponent방식으로 찾을 것임
인스펙터에서 Player를 연결한다면 Player수정시 인스펙터 연결이 해제될 수 있음
해제 될때마다 Player를 호출하던 오브젝트들을 다 찾아서 다시 다 연결해줘야함
싱글톤을 이용하면 Player자체가 프로퍼티에 접근해 참조를 연결하기때문에

Player위치가 변동하든 스크립트가 바뀌든 상관없음



Player 말 그대롭니다.



핵심 로직을 분석해보세요 (Move, CameraLook, IsGrounded)

Move와 CameraLook 함수를 각각 FixedUpdate, LateUpdate에서 호출하는 이유에 대해 생각해보세요.



Move : Rigidbody를 통해 물체에 물리적인 힘을 가함
Update는 매 프레임마다 호출 하드웨어 성능에 따라 이용자경험이 달라짐
슈퍼컴은 시속100km 일반컴은 시속10km식의 차이 발생
FixedUpdate 미리 설정된 값에따라 일정하게 호출된다고함 위와같은 문제를 해결하기위해
유니티가 제공한다고 봐도 되는가 물리연산은 이용자에따라 차이가 없도록 FixedUpdate가 좋단다
LateUpdate 물리연산 이후에 호출됨 머리가 돌고나서 시선이 바뀐다는 개념상의 이해에 부합한다
같은 FixedUpdate에 있다면? 머리돌리는 함수 다음에 호출되도 문제 없을거 같긴한데

명시적인 가독성 측면에서 좋..다고 보는건가







분석 문제 : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.



별도의 UI 스크립트를 만드는 이유에 대해 객체지향적 관점에서 생각해보세요.

UI_Bar 는 체력바와 같은 수치를 시각적으로 표현해주는 역할 변동이 있을때마다 Update되야 할것이다
UI_Inventory 는 흔히 생각하는 인벤토리역할 그 잡체 역시 역할 변동이 있을때마다 Update되야 할것이다
둘이 합치면 PPAP 하는일도 2배 Update도 2배 나같으면 일 안한다
인력을 더 쓴다고 보면 되겠다



인터페이스의 특징에 대해 정리해보고 구현된 로직을 분석해보세요.

인터페이스 상속관계일때 파생클래스에서 강제적으로 모든 요소를 구현해야한다

구현안하면 넌 모찌나간다 = 미래의 개발자 자신에게 이건 꼭 구현해야돼!를 남긴다고 볼수있다

당연히 기능적으로 빠지면 안되는 요소일 것이다



핵심 로직을 분석해보세요. (UI 스크립트 구조, CampFire, DamageIndicator)

CampFire 접근한 물체에게 지속적으로 데미지를 줄것이다
OnTriggerEnter,Exit를 이용해 Enter시 해당 오브젝트에서 데미지를 입는 처리를 하는
컴포넌트가 있는지 TryGetComponent를 수행 후 참이면 배열에 Add한다
일정 주기마다 반복문으로 배열을 돌려 데미지를 입는 처리를 하는 함수를 호출한다

Exit시에도 데미지를 입는 처리를 하는 함수가 있는지 TryGetComponent를 수행 후 Remove한다



DamageIndicator
UI 이용자의 화면에 시각적으로 어떤 현상이 일어났음을 알리는 장치로 활용된다
직역하면 데미지상호작용이다
이용자가 데미지를 입으면 화면을 잠깐 붉게 칠하고 되돌아가는 기능을 수행한다
플레이어가 데미지를 입었을때 수행될 여러 기능 중 하나이기때문에
플레이어 컨티션의 델리게이트에 구독된다
코루틴을 이용해 붉게칠한상태가 이용자에게 보이도록 어느정도 기다린 후 원래대로 되돌린다

코루틴을 참조할수있는 변수를 이용해 중복해서 진입하지 않도록 막아주고있다
코루틴!=null 이면 Stop코루틴 하고 다시 시작시킨다

코드는 방어적일수록 좋은듯

분석 문제 : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

Interaction 기능의 구조와 핵심 로직을 분석해보세요.

Inventory 기능의 구조와 핵심 로직을 분석해보세요.



Interaction 상호작용
기능의 구조 :
다른 객체와의 상호작용 가능 여부를 판단함
실행은 상호작용 기능을 수행하는 인터페이스를 상속받은 상호작용물체

강의에서는 Player가 특정 키를 입력했을때 시점(카메라)중심으로 레이케스트

레이케스트에 걸린 객체가 상호작용 기능을 수행하는 인터페이스를 가지고있는지 판단
있으면 해당물체의 이름,설명을 보여줄 UI활성화, 해당물체의 상호작용 함수 실행 까지만

핵심 로직 :
사용자의 입력처리
시점(카메라)중심에서 발사되는 레이케스트

레이케스트를 맞은 물체가 상호작용 가능한지 판단



Inventory 말 그대롭니다

기능의 구조 :
실제 데이터를 가지고 있고 그 데이터를 UICanvas에게 전달해
시각적으로 보여줌으로써 이용자와의 소통을 간접적으로 담당

시각적으로 보이는 각각의 slot은 실제로 데이터를 가지고 있고

그 데이터를 기반으로 아이콘과 갯수를 표시해준다

slot은 배열의 형태로 관리된다

아이템을 추가하는 AddItem() Player가 루팅 가능한 아이템을 획득했을때 구독형태로 호출된다

아이템의 정보는 싱글톤을 통해 얻어진다

이 아이템이 여러개를 겹칠 수 있는 아이템인지, 아닌지1차적으로 판단한다

겹쳐 지는가 판단하는 별도의 함수를 호출, 이 함수는 슬롯을 반환한다

모든 슬롯을 반복문으로 검증한다

현재 아이템 정보와 슬롯의 아이템 정보가 같고 현재 갯수가 최대 갯수보다 작으면 이 슬롯을 반환

아니면 null반환

null이 아닌 값이 반환됬다면 해당 슬롯의 개수를 증가하고
데이터가 변동되었으니 Canvas를 업데이트(최신화)

함수return



겹칠 수 없는 아이템이면 아직 함수를 빠져나가지 않았으니 다음 함수를 실행

빈 슬롯이 있는지 찾는 함수 실행

모든 슬롯을 반복문으로 검증한다

아이템정보가 null인 슬롯을 찾아 반환한다 빈 슬롯이라는 뜻이다

빈 슬롯이면 해당 슬롯의 아이템정보 = 현재 아이템정보

데이터가 변동되었으니 Canvas를 업데이트(최신화)

함수return



빈 슬롯이 없다면 null을 반환한다

빈 슬롯이 없다면 아이템을 다시 뱉는다

슬롯을 선택 했을때(호출은 슬롯자체에 있는 별도의 cs로부터 버튼식 호출)

해당 슬롯이 가지고 있는 아이템 정보를 보여준다
장비 아이템, 소모 아이템 공통인 부분 이름, 설명은 조건없이 보여주고
공통적이지 않은 부분 효과부위(체력,기력)와 효과(상승수치)는
일단 지우고
아이템이 정보를 가지고 있는지 판단 후 보여준다



선택한 슬롯의 아이템 유형에 따라 버튼 활성화가 다르다

장비 아이템이면 활성화 장비 아이템이고 장착중이면 해제

소모품이면 장비,해제 버튼 자리에 사용

버리기시 드랍용 프리팹을 생성하고 슬롯의 아이템정보를 비움



요약 :
템 주웠음 > 가지고있는 템이고 겹칠수있는 템인가? 겹칩 : 빈슬롯찾음
겹칠수도 없고 빈슬롯도 없으면 먹뱉
인벤에서 템 누름 템이름, 설명, 정보 보여줌

장비면 장착,해제 버튼 활성화
소모품이면 사용 버튼 활성화
버튼에 맞는 액션
